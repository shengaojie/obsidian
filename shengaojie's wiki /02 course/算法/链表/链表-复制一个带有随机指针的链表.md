[leetcode](https://leetcode.cn/problems/copy-list-with-random-pointer/)

> [!使用hashMap]
> 将新节点和老节点的关系保存在hashMap中，老节点的next 和 random指向什么位置，新节点的就指向对应的value值 

```java
public Node copyWithHash(Node head){  
	if (head == null) {  
		return null;  
	}  
	  
	//定义一个map来存储两种node  
	HashMap<Node, Node> map = new HashMap<>();  
	//用来遍历head链表  
	Node cur = head;  
	while (cur != null) {  
		map.put(cur, new Node(cur.val));  
		cur = cur.next;  
	}  
	  
	//继续遍历原先的node，每次都组装好一个新node节点  
	cur = head;  
	while (cur != null) {  
		//新node的next就是原先node.next位置对应的value值，random位置同理  
		map.get(cur).next = map.get(cur.next);  
		map.get(cur).random = map.get(cur.random);  
		cur = cur.next;  
	}  
	  
	return map.get(head);  
}
```




> [!老节点后面加入新节点在分离] 
> 1. 每个老节点的后面加入一个新节点
> 2. 将加入的新节点的random指针连上
> 3. 新老两个链表分离

```java
public Node copy(Node head){  
	if (head == null) {  
		return null;  
	}  
	Node cur = head;  
	Node next = null;  
	// copy Node and link to every node  
	// 1 -> 2  
	// 1 -> 1' -> 2  
	while (cur != null) {  
		// cur 老 next 老节点的下一个  
		next = cur.next;  
		cur.next = new Node(cur.val);  
		cur.next.next = next;  
		cur = next;  
	}  
	  
	  
	// rand指针  
	// 1 -> 1' -> 2 -> 2'  
	// 每两个为一组遍历  
	cur = head;  
	Node curCopy = null;  
	while (cur != null) {  
		next = cur.next.next;  
		curCopy = cur.next;  
		curCopy.random = cur.random == null ? null : cur.random.next;  
		cur = next;  
	}  
	  
	//分离两个链表  
	cur = head;  
	//新的头结点  
	Node res = head.next;  
	while (cur != null) {  
		next = cur.next.next;  
		curCopy = cur.next;  
		cur.next = next;  
		curCopy.next = next == null ? null : next.next;  
		cur = next;  
	}  
	  
	return res;  
}
```