
> [!NOTE] 异或运算
> 相同为0，不同为1


> [!NOTE] 同或运算
> 不同为0，相同为1

* i 性质：
1. 0^N = N   N^N = 0
2. 异或运算满足交换律和结合律

**技巧：异或运算就记成无进位相加**
![[CleanShot 2024-02-27 at 21.43.44@2x.png]]





> [!example] 使用异或交换两个数的值

使用异或完成两个值的交换
![[CleanShot 2024-02-27 at 21.59.09@2x.png]]
唯一需要主要的是，a和b的值是可以相同的，但是a和b不能指向同一片内存区域




> [!example] 查找数组中唯一奇数次的奇数
> 一个数组中只有一个数字出现为奇数，找到这个数字

```java
public static void find(int[] arr){  
  
	int eor = 0;  
	for (int i = 0; i < arr.length; i++) {  
	eor ^= arr[i];  
	}  
  
	System.out.println("这个奇数是：" + eor);  
}
```




> [!example] 数组中只有两种出现奇数次的数，找到这两个数
```java
//假设这两个数分别是a和b  
public static void findOddTimes(int[] arr){  
	int eor = 0;  
	//定义一个eor，不断的去和数组中的所有的数去异或  
	//因为只有两种数是奇数个，所以所有的偶数数目的数字都会消除  
	//最后的结果是eor = a ^ b  
	for (int i = 0; i < arr.length; i++) {  
		eor ^= arr[i];  
	}  
	  
	//找到eor最右边的那个1，假设是第n位  
	int rightOne = eor & (~eor + 1);  
	//另外定义一个eor  
	int otherEor = 0;  
	for (int i = 0; i < arr.length; i++) {  
		//第二个eor只和第n位为1的数字进行异或  
		if ((arr[i] & rightOne) != 0) {  
		//循环结束后的eor必然是a或者是b中的一个，另一个是eor ^ otherEor  
		otherEor ^= arr[i];  
		}  
	}  	  
	System.out.println("one is: " +otherEor + "\nanother is:" +(eor ^ otherEor));  

}
```



> [!example] 统计一个整数对应的二进制数中1的个数

```java  
public static void bit1Counts(int n){  
	int count = 0;  
	// 001101100 n  
	// 000000100 rightOne  
	// 001101000 n ^ rightOne  
	while(n != 0){  
		int rightOne = n & ((~n) + 1);  
		count++;  
		n = n ^ rightOne;  
	}  
	  
	System.out.println("n的二进制中1的个数为：" + count);  
  
}

```




