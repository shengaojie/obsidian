# 浅拷贝

> [!notion] 
> 浅拷贝是指在对一个对象进行拷贝时，**只拷贝对象本身和其中的基本数据类型**，**而不拷贝对象内部的引用类型**。因此，在浅拷贝的对象中，引用类型的变量指向的依旧是原始对象中的引用。


> [!note] 实现
>  只需要实现 `Cloneable`接口，重写 `clone`方法

```java
public class Citation implements Cloneable{  
  
	private String name;  
	  
	public String getName() {  
		return name;  
	}  
	  
	public void setName(String name) {  
		this.name = name;  
	}  
	  
	@Override  
	protected Citation clone() throws CloneNotSupportedException {  
		return (Citation) super.clone();  
	}  
	  
	public void show(){  
		System.out.println(name + " 同学获得本学期的三好学生奖！！！");  
	}  
}
```

# 深拷贝

![[CleanShot 2023-12-05 at 00.31.41@2x.png]]
> [!notion] 
>  [深拷贝]是指在对一个对象进行拷贝时，**不仅拷贝对象本身和其中的基本数据类型，同时也拷贝对象内部的引用类型**。因此，在深拷贝的对象中，引用类型的变量指向的是全新的对象。

## 实现

> [!list] 方式1：对象的序列化
```java
> public class Student implements Serializable {  
	private String name;  
	  
	public Student(String name) {  
		this.name = name;  
	}  
	  	  
	@Override  
	public String toString() {  
		return "Student{" +  
		"name='" + name + '\'' +  
		'}';  
		}  
}
```

```java
public class Teacher implements Serializable,Cloneable {  
	private String name;  
	private Student student;  
	  
	private String filePath;  
	  
	public Teacher(String name) {  
		this.name = name;  
		//classpath：/Users/shengaojie/code/Java/IDEA/designMode/out/production/designMode/build/prototype/deep_copy  
	filePath = this.getClass().getResource("").getPath();  
		System.out.println(filePath);  
	}  
	  
	public void setStudent(Student student) {  
		this.student = student;  
	}  
	  
	@Override  
	public Teacher clone() {  
		try(ObjectOutputStream obo =  
		new ObjectOutputStream(new FileOutputStream(filePath + "teacher.txt"));  
		ObjectInputStream obi =  
		new ObjectInputStream(new FileInputStream(filePath + "teacher.txt"))){  
		obo.writeObject(this);  
		obo.flush(); 

		return (Teacher)obi.readObject();  
	  
		} catch (IOException | ClassNotFoundException e) {  
		throw new RuntimeException(e);  
		}  
	}  
	  
	@Override  
	public String toString() {  
	return "Teacher{" +  
	"name='" + name + '\'' +  
	", student=" + student +  
	'}';  
	}  
}
```

注意：
1. 需要 `Student`和 `Teacher`类都实现 `Serializable`接口，并且 `Teacher`类实现 `Cloneable`
2. 需要使用 `ObjectOutputStream` 和 `ObjectInputStream`，先将 `this`对象写入到一个`teacher.txt`文件中去。在将文件中的数据读取出来转换成一个`Teacher`对象



> [!NOTE] 方式2：手动编写clone()方法

```java
public class Student implements Cloneable {  
	private String name;  
	  
	public Student(String name) {  
		this.name = name;  
	}  
	  	  
	//引用类型的成员变量需要重写clone方法  
	//如果Student中的成员变量还有引用类型，其也需要重写clone方法  
	@Override  
	protected Object clone() throws CloneNotSupportedException {  
		return super.clone();  
	}  
	  
	@Override  
	public String toString() {  
		return "Student{" +  
		"name='" + name + '\'' +  
		'}';  
	}  
}
```

```java
public class Teacher implements Cloneable {  
private String name;  
private Student student;  
  
private String filePath;  
  
	public Teacher(String name) {  
		this.name = name;  
	//classpath：/Users/shengaojie/code/Java/IDEA/designMode/out/production/designMode/build/prototype/deep_copy  
	filePath = this.getClass().getResource("").getPath();  
		System.out.println(filePath);  
	}  
	  
	public void setStudent(Student student) {  
		this.student = student;  
	}  
	  
	@Override  
	public Teacher clone() {  
		Teacher cloneTeacher;  
		try {  
			cloneTeacher = (Teacher)super.clone();  
		//克隆出来的Student是一个深拷贝  
		//给Teacher中的Student赋值，得到一个深拷贝的Teacher对象  
			cloneTeacher.setStudent((Student) cloneTeacher.student.clone());  
		} catch (CloneNotSupportedException e) {  
			throw new RuntimeException(e);  
	}  
	  
		return cloneTeacher;  
	}  
	  
	@Override  
	public String toString() {  
		return "Teacher{" +  
			"name='" + name + '\'' +  
			", student=" + student +  
			'}';  
	}  
}
```

1. 需要 `Student` 和 `Teacher`类都实现 `Cloneable`接口
2. 在 `Teacher`中的 `clone`方法中，需要先clone得到一个`cloneTeacher`，因为 `Student`是一个引用类型，因此需要通过`cloneTeacher`的`setStudent`方法给该类设置一个深拷贝的`Student`。
3. 因为这里的 `Student`中的成员变量都是基本类型了，如果还有引用类型的话，这个引用类型也需要重写 `clone`方法，并且在 `Student`的 `clone`方法中加入对应的setXXX方法。