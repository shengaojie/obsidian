
> [!why] 
> 1. 编译时检查元素的添加类型
> 2. 减少类型的转换次数
> 3. 提升代码的灵活性



> [!NOTE] 泛型类
```java
class 类名 <K,V>{

}
```



> [!NOTE] 泛型接口
```java
interface 接口名称 <T>{

}
```




> [!NOTE] 泛型方法

```java
修饰符 <T,R...> 返回类型 方法名(参数列表){

}
```


* i 泛型方法和使用泛型的区别
```java
public class Bird<K>{
	public <T, R> void fly(T t, R r) {}//泛型方法
	public void eat(K k){  //使用泛型的方法}
}
```





> [!NOTE] 泛型的通配和继承

`?`:表示可以接受任意类型的

`? extend A`表示接受的类型为A和A的子类，规定的接受的上限是A

`? entend A`: 表示接受的类型为A和A的父类，规定了接受的下限是A



> [!conclusion] 
> 1. 普通的属性和方法可以使用泛型
> 2. 使用泛型数组无法初始化，因为无法分配空间
> 3. 静态方法中不能使用类的泛型
> 4. 如果创建对象时，没有指定泛型，就是默认为Object