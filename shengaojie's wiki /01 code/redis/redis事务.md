
> [!notion] 
> * 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有的命令都会被序列化，**按顺序的串行化执行而不会被其他命令插入**
> 




> [!method] 
> 
```shell
discard:     # 取消事务
exec：       # 执行事务快内的所有的命令
multi：      # 标记一个事务的开始
unwatch：    # 取消watch命令对所有key的监视
watch：      # 监视所有的key
 ```



> [!conclusion] 
> * 开始事务：通过`multil`开始一个事务
> *  入队：将多个命令加入到事务中，这些命令不会被执行
> *   执行：由`exec`命令触发事务
> 
>


> [!compare] redis事务  VS 数据库事务
> * 单独的隔离性：Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的
> * 没有隔离级别的概念： 因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了
> * 不完全保证原子性：**Redis的事务不保证原子性**，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力
> * 排他性：Redis会保证一个事务内的命令依次执行，而不会被其它命令插入





> [!example] 案例-正常执行

![[CleanShot 2024-01-17 at 21.00.42@2x.png]]


> [!example] 案例-放弃事务

![[CleanShot 2024-01-17 at 21.04.14@2x.png]]


> [!example] 案例-语法错误，编译不通过

![[CleanShot 2024-01-17 at 21.06.40@2x.png]]



> [!example] 案例-编译通过，执行异常

![[CleanShot 2024-01-17 at 21.09.38@2x.png]]



> [!example] 案例-watch监控
>*  watch：是悲观锁的机制，对一个key进行watch的时候，如果此时的事务执行前会检查是否有别的客户端对该key进行了修改，如果发现了修改，则放弃此次的事务。
> * unwatch：对所有的监视的对象进行解锁

![[CleanShot 2024-01-17 at 21.15.36@2x.png]]

![[CleanShot 2024-01-17 at 21.24.05@2x.png]]