[[大话设计模式.pdf#page=31&annotation=4166R]]
> [!notion] 
> 提供一个创建**一系列**相关或相互依赖对象的接口，而不需要指定它们具体的类


# UML
![[CleanShot 2023-12-12 at 16.33.27@2x.png]]

# 实现

### 产品相关
> [!NOTE] AbstractProductA
```java
public interface IUser {  
	void addUser(User user);  
	  
	void getUser(int i);  
}
```
> [!NOTE] ConcreteProductA
```java
public class MysqlImplUser implements IUser{  
	@Override  
	public void addUser(User user) {  
		System.out.println("使用Mysql增加一个User对象");  
	}  
	  
	@Override  
	public void getUser(int i) {  
		System.out.println("使用Mysql获取一个User对象");  
	}  
}
```


### 工厂相关
> [!NOTE] AbstractFactory

```java
public interface DataBaseFactory {  
	IUser getUserInfo();  
	IDepartment getDepartment();  
}
```

> [!NOTE] ConcreteFactory
```java
public class MysqlFactory implements DataBaseFactory{  
  
	@Override  
	public IUser getUserInfo() {  
	   return new MysqlImplUser();  
	}  
	  
	@Override  
	public IDepartment getDepartment() {  
	   return new MysqlImplDepartment();  
	}  
}
```

> [!NOTE] Client

```java
public class Client {  
	static DataBaseFactory factory;  
	public static void main(String[] args) {  
		factory = new OracleFactory();  
		IUser userInfo = factory.getUserInfo();  
		userInfo.getUser(1);  
		userInfo.addUser(new User());  
		  
		IDepartment department = factory.getDepartment();  
		department.getDepartment(1);  
		department.addDepartment(new Department());  
	  
	}  
}
```


> [!understand] 
> 1. 相比于[[工厂方法模式]]，抽象产品的数量不止一个，而是一族，一系列的产品
> 2. 一个工厂中可以生产的不仅仅是一个产品了，而是一族产品
>

让具体的创建的过程和客户端分析，客户端通过接口去调用对应的方法，客户端只认识 `IUser` 和 `IDepartment`，不知道具体是谁调用的。




# 结合简单工厂模式的改进
 
> [!NOTE] 
>  1. 抽象工厂模式存在的缺点： 如果想要增加一个抽象的产品，需要新增三个类（一个抽象的产品类，两个实现类），同时需要修改三个类（抽象工厂和两个实现类中增加一个方法）
>  2. 使用简单工厂模式来代替了抽象工厂和具体的工厂，通过 `switch`来判断使用具体的工厂
>  

```java
public class DataAccess {  
	private static String sqlName = "Mysql";  
		IUser getUserInfo(){  
		IUser iUser = null;  
		switch (sqlName){  
			case "Mysql":  
				iUser = new MysqlImplUser();  
				break;  
			case "Oracle":  
				iUser = new OracleImpIUser();  
				break;  
			default:  
				throw new RuntimeException("不支持的数据库类型");  
		}  
		return iUser;  
	  
	}  
	  
	IDepartment getDepartment(){  
		IDepartment iDepartment = null;  
		switch (sqlName){  
			case "Mysql":  
				iDepartment = new MysqlImplDepartment();  
				break;  
			case "Oracle":  
				iDepartment = new OracleImplDepartment();  
				break;  
			default:  
				throw new RuntimeException("不支持的数据库类型");  
		}  
		return iDepartment;    
	}  
  
}

```



# 使用反射进一步优化


> [!NOTE] 
> 如何省略到上面繁琐的 `switch`语句，上面的实例化对象时通过特定的对象实现的。而通过`反射`的话，可以通过**字符串来实例化对象**，并且字符串又可以在配置文件中读取。因此通过更改配置文件就能实现创建不同的对象

```java
public class DataAccessWithReflect {  
  
	IUser getUserInfo(){  	  
		return getIUser();  
	}  
  
	public IUser getIUser() {  
		IUser iUser = null;  
		String filePath = this.getClass().getResource("").getPath();  
		System.out.println(filePath);  
		try{  
			Properties properties = new Properties();  
			properties.load(new FileReader(filePath + "sqlInfo.properties"));  
			String sqlName = properties.getProperty("sqlName");  
			System.out.println("sqlName = " + sqlName);  
			  
			Class<?> cls = Class.forName(sqlName);  
			Constructor<?> constructor = cls.getConstructor();  
			iUser = (IUser)constructor.newInstance();    
		}catch (Exception e){  
			e.printStackTrace();  
		}  
	  
	return iUser;  
	  
	}  
  
}
```

```properties
sqlName=build.factory.abstract_factory.example01.product.MysqlImplUser
```

> [!linked] 
> [[简单工厂模式]]   
> [[工厂方法模式]]  
> [[reflection]]

