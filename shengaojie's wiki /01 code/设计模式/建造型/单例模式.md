
> [!notion]
> 保证一个类只有一个实例，并且提供一个访问它的全局访问点


# UML
![[CleanShot 2023-12-15 at 14.39.22@2x.png]]

> [!NOTE] 
> 1. 有一个成员变量 `Singleton`
> 2. 私有化构造方法，防止别的类中new
> 3. 提供一个静态方法获取 `Singleton`对象




# 实现


## 饿汉式

> [!understand] 
> 1. 饿汉式：表示很饥饿，在不吃东西要饿死了，所以实现的形式通过静态变量初始化的时候创建对象，又因为静态变量的初始化只有一次，所以这**种方式是线程安全的**。
> 2. 但是由于这个类一加载就需要创建一个对象，所以会提前占用系统的资源


> [!NOTE] Singleton


```java
public class Singleton {  
	private static Singleton singleton = new Singleton();  
	  
	public static Singleton getInstance(){  
		return singleton;  
	}  
}
```


## 懒汉式
> [!understand] 
>1. 懒汉式：因为太懒，所以自己不想动，所以不会咋静态变量初始化的时候创建对象。**而要等到需要使用这个对象的时候。**
>2. 不会提前占用系统资源，但是存在线程安全的问题

### 线程不安全

> [!NOTE] Singleton

```java
public class Singleton1 {  
	private static Singleton1 singleton1;  
	  
	public static Singleton1 getInstance(){  
		if(singleton1 == null){  
			singleton1 = new Singleton1();  
		}  
		return singleton1;  
	}  
}

```


### 线程安全
#### 方式1（加锁）：
```java
public class Singleton2 {  
	private static Singleton2 instance;  
	private Singleton2(){} 
	public static synchronized Singleton2 getInstance(){  
		if(instance == null){  
			instance = new Singleton2();  
		}  
			return instance;  
		}  
}
```


#### 方式2（通过静态内部类的成员变量）：⭐️⭐️⭐️⭐️⭐️
```java
public class Singleton3 {  
	private static Singleton3 instance;  
    private Singleton3() {}  
	private static class SingletonCreate{  
	private static final Singleton3 INSTANCE = new Singleton3();  
	}  
	  
	public static Singleton3 getInstance(){  
		return SingletonCreate.INSTANCE;  
	}  
}
```

#### 方式3（双重检查）：
```java
public class Singleton4 {  
	private static Singleton4 singleton4 = null;  

	private Singleton4() {}  
	  
	public static Singleton4 getInstance(){  
		if(singleton4 == null){  
		synchronized (Singleton4.class){  
			if(singleton4 == null){  
				singleton4 = new Singleton4();  
			}  
		}  
	}    
	return singleton4;  
	}  
}
```

