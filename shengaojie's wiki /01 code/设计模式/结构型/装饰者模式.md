
> [!what] 
> 动态的给一些类增加一些职责




![[CleanShot 2023-12-04 at 20.31.20@2x.png]]


> [!para] 实现
> 

- list Componet：
```java
public interface Activity {  
	void doThisWork();  
}
```

- list ConcreteComponent：
```java
public class People1 implements Activity{  
	@Override  
	public void doThisWork() {  
		//这个是这个人的核心工作  
		System.out.println("去实验室.....");  
	}  
}
```

- list Decorator：
```java
public abstract class DecoratorActivity implements Activity{  
  
	Activity activity;  
	  
	public void setActivity(Activity activity){  
		this.activity = activity;  
	}  
}
```

- list ConcreteDecorator：
```java
public class ConcreteDecoratorActivityA extends DecoratorActivity{  
  
	@Override  
	public void doThisWork() {  
		System.out.println("先刷牙...");  
		System.out.println("在洗头...");  
		activity.doThisWork();  
		System.out.println("早饭带到实验室吃....");  
	}  
}
```

- list Client：
```java
public class Client {  
  
	public static void main(String[] args) {  
		People1 people1 = new People1();  
		People2 people2 = new People2();  
		  
		//创建具体的装饰者类  
		DecoratorActivity decoratorActivityA = new ConcreteDecoratorActivityA();  
		DecoratorActivity decoratorActivityB = new ConcreteDecoratorActivityB();  
		decoratorActivityA.setActivity(people1);  
		decoratorActivityB.setActivity(people2);  
		  
		decoratorActivityA.doThisWork();  
		  
		System.out.println("我是分界线.......");  
		decoratorActivityB.doThisWork();  
		}  
}

```

> [!understand] 
> 1. 装饰者模式是将一个类的核心功能和非核心的功能分离，早上是去实验室是必须要做的事情。至于去实验式之前干什么，之后干嘛什么没有啥要求。
> 2. 每个装饰者只关心自己的装饰功能，多个装饰者之间可以形成装饰者链。这是通过Decorator中的setComponet方法实现的



> [!NOTE] 实现细节
> 1. `ConcreteComponent` 和 `Decorator`都需要继承或者实现 `Component`
> 2. `Decorator` 中需要聚合 `Component`，并且通过 `setComponent(Component componet)` ，可以保证原有的`Componet`的功能正常实现。
> 3. 如果只有一个具体的实现类的话，如上面示例中只有一个People，则可以让`Decorator`直接继承People，可以灵活的使用


> [!linked]
> [[建造者模式]]：建造者模式中的构建的步骤是固定的，先干嘛后干嘛，但是怎么做事变化的。装饰者模式是围绕一个核心功能展开的，没有固定的构建的步骤



> [!Example] 
> 1. Java中的Filewriter 是在 outPutStream基础上的功能的扩展
