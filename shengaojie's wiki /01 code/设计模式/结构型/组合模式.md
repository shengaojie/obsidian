
> [!notion] 
> 将对象组合成树形结构来表示“整体和部分”。让用户对单个对象和组合对象的使用具有一致性。

# UML
![[CleanShot 2023-12-14 at 16.54.39@2x.png]]



# 实现

> [!NOTE] Componet

```java
public abstract class Company {  
	String name;  
	int depth;  
	  
	public Company(String name,int depth) {  
		this.name = name;  
		this.depth = depth;  
	}  
	  
	public abstract void add(Company company);  
	  
	public abstract void remove(Company company);  
	  
	public abstract void display();  
}
```



> [!NOTE] Composite
> 含有子节点的
```java
public class ConcreteCompany extends Company{  
	List<Company> companyList = new ArrayList<>();  
	  
	public ConcreteCompany(String name, int depth) {  
		super(name, depth);  
	}  
	 
	@Override  
	public void add(Company company) {  
		companyList.add(company);  
	}  
	  
	@Override  
	public void remove(Company company) {  
		companyList.remove(company);  
	}  
	  
	@Override  
	public void display() {  
		for (int i = 0; i < depth; i++) {  
			System.out.print("--");  
		}  
		System.out.println(name);  
		for (Company company : companyList) {  
			company.display();  
		}  
	}  
}
```


> [!NOTE] Leaf
> 不含有子节点的
```java
public class FiscalDepartment extends Company{  
  
	public FiscalDepartment(String name, int depth) {  
		super(name, depth);  
	}  
	  
	@Override  
	public void add(Company company) {}  
	  
	@Override  
	public void remove(Company company) {}  
	  
	@Override  
	public void display() {  
		for (int i = 0; i < depth; i++) {  
			System.out.print("--");  
		}  
			System.out.println(name);  
	}  
}
```

```java
public class HRDepartment extends Company{  
	public HRDepartment(String name, int depth) {  
		super(name, depth);  
	}  
	  
	@Override  
	public void add(Company company) {  }  
	  
	@Override  
	public void remove(Company company) { }  
	  
	@Override  
	public void display() {  
		for (int i = 0; i < depth; i++) {  
			System.out.print("--");  
		}  
		System.out.println(name);  
	}  
}
```



> [!understand] 
> 1.`Composite`中需要有一个 `List<Component`>存储该节点下的所有的叶子节点
> 2. 因为在 `Component`中定义了 `add`、`remove`这样的抽象方法，所以无论是叶子节点还是非叶子节点都需要重写这两个方法。
> 	- 但是对于叶子节点而言，因为不存在 `List<Componet>`，所以重写这两个方法没有什么意义
> 	- 非叶子节点需要重写这两个方法



> [!advantage] 
> 组合模式可以让用户一致的使用组合结构和单个对象，不用为对象的类型去写一些判断语句



> [!linked] 
> 树
> 

