
> [!notion] 
> 定义了一族算法，并且封装起来，让他们之间可以相互替换


# UML类图
![[CleanShot 2023-12-04 at 08.49.19@2x.png]]


# 实现
> [!NOTE] Context：

```java
public class SalesMan {  
//需要再成员变量中加入Strategy接口  
	private Strategy strategy;  
	  
	//在构造方法的中传入具体的实现类  
	public SalesMan(Strategy strategy) {  
		this.strategy = strategy;  
	}  
	  
	//在调用show方法的时候，具体的实现类会调用具体的show方法  
	public void salesManShow(){  
		strategy.show();  
	}  
	  
	  
	public void setStrategy(Strategy strategy) {  
		this.strategy = strategy;  
	}  
}
```

> [!NOTE] Strategy：

```java
public interface Strategy {   
	void show();  
}
```

> [!NOTE] ConcreteStrategy：
```java
public class StrategyA implements Strategy{  
	@Override  
	public void show() {  
		System.out.println("买一送一");  
	}  
}
```


# 理解
> [!understand]
> 1. **策略模式定义的一组算法，这组算法完成的是相同的功能，但是实现是不同的**。如Runnable中的run方法，run方法中是线程需要执行的任务，每个线程的任务又是不同的。线程执行的任务是一个抽象的算法，每个线程具体的实现是每个具体的算法
> 2. 策略模式会将具体策略的实现和调用的客户端解耦，但是此时的客户端还是需要通过条件语句来判断，具体使用哪一种策略。如果不想要判断在客户端中出现，可以将判断延迟到Context对象中去。也就是将策略模式和[[简单工厂模式]]结合，将客户端完全和具体的算法解耦
> 3. 如果没有策略模式的话，会将一个算法的不同实现的场景堆砌在一个类中，这个类中会充斥着大量的判断语句。


> [!example]
>Runnable中的run方法就是采用的策略模式。线程启动后会去指定相应的任务（抽象的算法），具体的任务（不同的具体算法）是怎么实现的，是通过Runnable接口的实现类传入的。