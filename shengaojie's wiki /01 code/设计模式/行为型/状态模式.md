
> [!notion] 
> 当控制一个对象那个的状态转换的条件表达式过于繁琐的时候。可以把状态的判断逻辑，转义到一系列的状态类中，可以简化这个判断的逻辑。
>




# UML
![[CleanShot 2023-12-12 at 15.33.41@2x.png]]


# 实现

> [!NOTE] Context
```java
	public class OneDay {  
		State state;  
	  
	public State getState() {  
		return state;  
	}  
	  
	public void setState(State state) {  
		this.state = state;  
	}  
	  
	//该方法中，执行任务的是具体的状态类 
	public void doJob(){  
		state.doAction(this);  
	}  
}
```

> [!NOTE] State
```java
public abstract class State {  
  abstract void doAction(OneDay oneDay);  
}

```



> [!NOTE] ConcreState
```java
public class Work extends State {  
	@Override  
	void doAction(OneDay oneDay) {  
		  
		System.out.println("14-17点属于工作状态....");	  
		oneDay.setState(new Relax());  
	  
	}  
}
```

```java
public class Relax extends State{  
	@Override  
	void doAction(OneDay oneDay) {  
		System.out.println("11-14点是休息时间.....,我处于休息状态");  
		oneDay.setState(new Games());  
	}  
}

```

> [!NOTE] Client
```java
public class Client {  
	public static void main(String[] args) {  
		OneDay oneDay = new OneDay();  
		oneDay.setState(new Work());  
		oneDay.doJob();  
		oneDay.doJob();  
		oneDay.doJob();  
  }   
}
```



> [!understand] 
> 1. `Context` 需要根据具体的状态去采取不同的行动，所以如果之间的判断很复杂的话，会在`Context`中加入大量的if判断，因此可以将`State`抽取出来，**并且作为成员变量引入到 `Context`中**
> 2. 同时注意到`Context`对象中的 `request`方法实际上是具体的 `State`在执行
> 3. 并且 `State`中的 `handle`方法的参数是一个 `Context`对象，因为需要执行完对应的方法之后，需要进行 `State`的转变。
> 
>

