
> [!notion]
> 定义了**一种一对多**的依赖关系，让多个观察者对象同时监听某一主题对象。当这个主题对象发生改变的时候，会通知所有的观察者对象。同时这种模式也称为**发布订阅模式**。



# UML类图
![[CleanShot 2023-12-05 at 20.52.04@2x.png]]


> [!NOTE] 
> 1. `Subject`抽象类中会有一个维护所有的 `Observer`的集合。并且定义 `Attach`和 `Detach`方法增加或者删除 `Observer`对象
> 2. `Observer` 可以是一个接口，也可是一个抽象类
> 3. `ConcreteSubject`中可以有一个状态，并且在 `ConcreteObserver`中会使用到。如果是发布订阅的形式，通常会给  `Notify`方法增加一个参数


# 实现

> [!NOTE] Subject
```java
public interface Subject {  
	//添加订阅者  
	void attach(Observer observer);  
	  
	//删除订阅者  
	void detach(Observer observer);  
	  
	//通知所有的订阅者更新消息  
	void notify(String message);  
}
```


> [!NOTE] ConcreteSubject
```java
public class SubscriptionSubject implements Subject{  
  
	//聚合所有的订阅者对象  
	private List<Observer> userList = new ArrayList<Observer>();  
	  
	@Override  
	public void attach(Observer observer) {  
		userList.add(observer);  
	}  
	  
	@Override  
	public void detach(Observer observer) {  
		userList.remove(observer);  
	}  
	  
	//通知所有的观察者对象去更新  
	@Override  
	public void notify(String message) {  
		for (Observer observer : userList) {  
			observer.update(message);  
		}    
	}  
}

```


> [!NOTE] Observer
```java
public interface Observer {  
	void update(String message);  
}
```

> [!NOTE] ConcreteObserver
```java
public class WeinxinUser implements Observer {  
	private String name;  
	  
	public WeinxinUser(String name) {  
		this.name = name;  
	}  
	  
	@Override  
	public void update(String message) {  
		System.out.println(name + "-" + message);  
	}  
}
```



> [!understand] 
> 观察者模式让原本耦合的双方都依赖于抽象，而不是具体的类。`Subject`依赖的是 `Observer`,而不是具体的一个 观察者对象。观察者模式的主要作用就是解耦，因此观察者模式是[[依赖倒转]]原则的最佳的体现
> 




> [!linked] 
> [[依赖倒转]]



> [!question] 事件委托
> 观察者模式存在的问题：尽管已经依赖于抽象了，但是“抽象通知者”,还是依赖“抽象观察者”，也就是说万一没有了抽象观察者这样的接口，通知功能就完成不了。另外就是每一个观察者，它不一定都需要接收到通知的。

