
> [!NOTION] 
> 在不破坏封装的前提下，捕获一个对象的内部状态，**并且在该对象之外保存这个状态**。这样以后就可以恢复这个对象到之前的状态


# UML
![[CleanShot 2023-12-12 at 22.45.21@2x.png]]


# 实现

> [!NOTE] Originator
> 用来创建一个备忘录，并且用它来记录自己内部的状态，并且可以用它恢复状态

```java
public class GameRole {  
	private int vit;  
	private int attack;  
	private int def;  
	  
	public GameRole() {  
		this.vit = 100;  
		this.attack = 100;  
		this.def = 100;  
	}  

    //在备忘录中保存
	public Memento savaMemento(){  
		return new Memento(this.vit,  
							this.attack,  
							this.def);  
	}  
	  
	//从备忘录中恢复
	public void recoverFromMemento(Memento memento){  
		this.vit = memento.vit;  
		this.attack = memento.attack;  
		this.def = memento.def;  
	}  
	  
	public void fight(){  
		this.vit = vit - 10;  
		this.attack = attack - 20;  
		this.def = 0;  
	  
	}  
	  
	@Override  
	public String toString() {  
		return "GameRole{" +  
		"vit=" + vit +  
		", attack=" + attack +  
		", def=" + def +  
		'}';  
	}  
}
```


> [!NOTE] Memento
> 负责存储Originator对象的内部状态，所以 `Memento`要和 `Originator`有一个样的属性

```java
public class Memento {  
	int vit;  
	int attack;  
	int def;  
	  
	public Memento(int vit, int attack, int def) {  
		this.vit = vit;  
		this.attack = attack;  
		this.def = def;  
	}  
}

```


> [!NOTE] Caretaker
> 负责保存好备忘录

```java
public class CareTaker {  
	private Memento memento;  
	  
	public Memento getMemento() {  
		return memento;  
	}  
	  
	public void setMemento(Memento memento) {  
		this.memento = memento;  
	}  
}
```


> [!NOTE] Client

```java
public class Client {  
	public static void main(String[] args) {  
		GameRole gameRole = new GameRole();  
		System.out.println("战斗开始前：");  
		System.out.println(gameRole);  
		Memento memento = gameRole.savaMemento();  
		CareTaker careTaker = new CareTaker();  
		careTaker.setMemento(memento);  
		  
		gameRole.fight();  
		System.out.println("战斗开始后：");  
		System.out.println(gameRole);  
		  
		gameRole.recoverFromMemento(careTaker.getMemento());  
		System.out.println("读档之后：");  
		System.out.println(gameRole);  
	}  
}
```

> [!understand]
> 1. `Originator`看到的是 `Memento`的宽接口，因为可以访问到 `Memento`中的各项数据
> 2. `Caretaker`看到的是 `Memento`的窄接口，因为只能访问到 `Memento`对象，无法访问内部数据


