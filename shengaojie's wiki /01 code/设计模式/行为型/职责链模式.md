
> [!notion] 
> 使得多个对象都有机会处理请求，从而避免了请求的发送者和接受者间的耦合关系。**将这个对象连成一条链，并且沿着这条链传递该请求，直到有一个对象处理这个请求。**




# UML
![[CleanShot 2023-12-14 at 09.59.07@2x.png]]


> [!NOTE] 
> 1. 除了最后一个 `Handler`，每一个 `Handler`的实现类都需要保持一个对下一个 `Handler`的引用。
> 2. 最后一个 `Handler`需要考虑，如果自己也处理不了的情况，避免请求没有得到正确的处理。

# 实现

> [!NOTE] Handle

```java
public abstract class Handler {  
	protected final static int NUM_ONE = 1;  
	protected final static int NUM_THREE = 3;  
	protected final static int NUM_SEVEN = 7;  
	  
	//该领导处理的请求天数区间  
	private int numStart;  
	private int numEnd;  
	  
	//申明后继者  
	private Handler nextHandler;  
	  
	public Handler(int numStart) {  
		this.numStart = numStart;  
	}  
	  
	public Handler(int numStart, int numEnd) {  
		this.numStart = numStart;  
		this.numEnd = numEnd;  
	}  
	  
	  
	//设置上级领导对象  
	public void setNextHandler(Handler nextHandler) {  
		this.nextHandler = nextHandler;  
	}  
	  
	//各级领导处理请假的方法  
	protected abstract void handlerLeave(LeaveRequest leave);  
	  
	//提交请假条  
	public final void submit(LeaveRequest leave){  
		if(this.nextHandler != null && leave.getNum() > this.numEnd){  
			//交给上级领导审批  
			this.nextHandler.submit(leave);  
		}else{  
			//该领导进行审批  
			this.handlerLeave(leave);  
			System.out.println("流程结束了");  
		}  
	}  
}
```



> [!NOTE] ConcreteHandle1
> 具体的处理者1

```java
public class GroupLeader extends Handler {  
  
	public GroupLeader() {  
		super(0,Handler.NUM_ONE);  
	}  
	  
	@Override  
	protected void handlerLeave(LeaveRequest leave) {  
		System.out.println(leave.getName() + "请假" +  
		leave.getNum() + "天" + leave.getContent());  
		System.out.println("小组长审批同意");  
		}  
}

```


> [!advantage] 
> 1. 接收者和发送者都没有对方的明确信息，并且链中的接受者也不知道链的全部的结构，**链中的元素只需要保持一个对后续节点的引用，而不需要有整个接受者的引用**。
> 2. 可以随时的增加或者是修改一个请求，非常灵活



> [!warning] 
> 一个请求可能会在最后都没有被处理，需要合理的做最后的处理工作




